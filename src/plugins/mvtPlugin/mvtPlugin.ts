import Backend from "../../core/Backend";
import Deferred from "../../core/Deferred";
import maybeParseJson from "../../core/maybeParseJson";
import resolveMatrix from "../../core/resolveMatrix";
import { Plugin } from "../../core/TerriaCatalogBuilder";
import { TerriaRectangle } from "../../core/types";
import { array, object, string } from "../../core/validators";
import { buildLegend } from "../legendPlugin/legendPlugin";
import compileFilterExpression, { MvtFilter } from "./compileFilterExpression";

interface MvtPluginOptions {
  backend: Backend;
}

type MvtLayerTypeDefinition = "fill" | "line";

interface MvtPaintDefinition {
  "fill-color"?: string;
  "line-color"?: string;
  "line-width"?: number;
}

interface MvtLayerDefinition {
  type: MvtLayerTypeDefinition;
  "source-layer": string;
  paint: MvtPaintDefinition;
  filter?: MvtFilter;
}

interface MvtStyleDefinition {
  layers: MvtLayerDefinition[];
}

// metadata.json is not part of the specification but typically generated by
// tippecanoe. https://github.com/mapbox/tippecanoe

const MVT_SUFFIX = "/{z}/{x}/{y}.mvt";
const getMvtMetadataUrl = (url: string): string => {
  return url.replace(MVT_SUFFIX, "/metadata.json");
};

// const RECT_BUFFER = 0.01; // One degree roughly translates to 100km
function buildMvtRectangle(metadata: any): TerriaRectangle | null {
  if (typeof metadata?.bounds !== "string") return null;
  const [west, south, east, north] = metadata.bounds
    .split(",")
    .map((str: string) => Number(str));
  const westEastBuffer = (east - west) * 0.2;
  const southNorthBuffer = (north - south) * 0.2;
  return {
    west: west - westEastBuffer,
    south: south - southNorthBuffer,
    east: east + westEastBuffer,
    north: north + southNorthBuffer,
  };
}

const validateMetadata = object({
  bounds: string,
  json: string,
});

const validateMetadataJson = object({
  tilestats: object({
    layers: array(object({ layer: string, geometry: string })),
  }),
});

const analyzeMetadata = (metadataText: string) => {
  const [metadata] = maybeParseJson(metadataText);
  if (!validateMetadata(metadata))
    return {
      rectangle: null,
      layers: null,
    };
  const rectangle = buildMvtRectangle(metadata);
  const [json] = maybeParseJson(metadata.json);
  if (!validateMetadataJson(json)) {
    return {
      rectangle: rectangle,
      layers: null,
    };
  }
  const layers = json.tilestats.layers;
  return { rectangle, layers };
};

const mvtPlugin =
  ({ backend }: MvtPluginOptions): Plugin =>
  (next) =>
  (node, parentId, logger) => {
    if (node.token.type !== "mvt") return next(node, parentId, logger);
    const legendName = node.token.props.get("legend");
    node.token.props.delete("legend");
    const deferredItem = next(node, parentId, logger);
    const deferredLegend = legendName
      ? backend.getLegend(logger, legendName)
      : new Deferred<null>((resolve) => resolve(null));
    const metadataUrl = getMvtMetadataUrl(node.token.url ?? "");
    const deferredMetadata = backend.fetch(logger, metadataUrl);
    return Deferred.all([deferredItem, deferredLegend, deferredMetadata]).then(
      ([item, legendMatrix, metadataText]) => {
        const { rectangle, layers } = analyzeMetadata(metadataText);
        const layersByName = layers?.reduce<
          Map<string, { layer: string; geometry: string }>
        >((acc, cur) => {
          acc.set(cur.layer, cur);
          return acc;
        }, new Map());
        const { rows: legendRows } = legendMatrix
          ? resolveMatrix(legendMatrix)
          : {
              rows: layers
                ? layers.map(
                    (layer, i, { length }) =>
                      new Map([
                        ["title", layer.layer],
                        ["mvtLayer", layer.layer],
                        ["color", `hsl(${(i / length) * 360} 100% 50%)`],
                      ])
                  )
                : [],
            };
        const filteredLegendRows = legendRows.filter((row) => {
          const mvtLayer = row.get("mvtLayer");
          if (!mvtLayer) return false;
          if (row.get("mvtAlwaysShow")) return true;
          const shouldIgnoreCurrentLayer =
            layersByName && !layersByName.has(mvtLayer);
          return !shouldIgnoreCurrentLayer;
        });
        const fillLayers: MvtLayerDefinition[] = [];
        const lineLayers: MvtLayerDefinition[] = [];
        filteredLegendRows
          .slice()
          .sort((a, b) => {
            const keyA = Number(a.get("mvtLayerOrder"));
            const keyB = Number(b.get("mvtLayerOrder"));
            if (Number.isNaN(keyA) || Number.isNaN(keyB)) {
              return 0;
            }
            return keyA - keyB;
          })
          .forEach((row) => {
            // Rows without the "mvtLayer" property are already filtered out.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const mvtLayer = row.get("mvtLayer")!;
            const layerMetadata = layersByName?.get(mvtLayer);
            const mvtFillColor = row.get("mvtFillColor");
            const mvtLineColor = row.get("mvtLineColor");
            const mvtLineWidth = Number(row.get("mvtLineWidth") || "1");
            const mvtFilter = row.get("mvtFilter");
            const legendColor = row.get("color");
            const legendOutlineColor = row.get("outlineColor");
            const compiledFilter = mvtFilter
              ? compileFilterExpression(logger, mvtFilter)
              : null;
            const base: Partial<MvtLayerDefinition> &
              Pick<MvtLayerDefinition, "source-layer"> = {
              "source-layer": mvtLayer,
            };
            if (compiledFilter) base.filter = compiledFilter;
            const fillColor = mvtFillColor ?? legendColor;
            const lineColor = mvtLineColor ?? legendOutlineColor ?? legendColor;
            if (
              mvtFillColor || // The user explicitly requires this layer to be filled, or...
              (layerMetadata?.geometry === "Polygon" && fillColor) // this is a polygon layer and we have a color with which to fill the polygons.
            ) {
              // Define fill style.
              fillLayers.push({
                ...base,
                type: "fill",
                paint: {
                  "fill-color": fillColor,
                },
              });
            }
            if (
              mvtLineColor ||
              legendOutlineColor || // The user explicitly requires this layer to be stroked, or...
              (layerMetadata?.geometry === "LineString" && lineColor) // this is a line layer and we have a color with which to stroke the lines.
            ) {
              // Define stroke style.
              lineLayers.push({
                ...base,
                type: "line",
                paint: {
                  "line-color": lineColor,
                  "line-width": mvtLineWidth,
                },
              });
            }
          });

        const style: MvtStyleDefinition = {
          layers: [...fillLayers, ...lineLayers],
        };
        item.style = style;
        item.legends = [buildLegend(filteredLegendRows)];

        if (rectangle) item.rectangle = rectangle;
        return item;
      }
    );
  };

export default mvtPlugin;
