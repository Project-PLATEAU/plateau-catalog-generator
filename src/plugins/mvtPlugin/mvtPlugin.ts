import Deferred from "../../core/Deferred";
import Logger from "../../core/Logger";
import makeParseJson from "../../core/makeParseJson";
import { Plugin } from "../../core/TerriaCatalogBuilder";
import { TerriaRectangle } from "../../core/types";
import { array, object, string } from "../../core/validators";
import { buildLegend } from "../legendPlugin/legendPlugin";
import compileFilterExpression, { MvtFilter } from "./compileFilterExpression";
import MvtPluginBackend, { MvtLegendEntry } from "./MvtPluginBackend";

interface MvtPluginOptions {
  backend: MvtPluginBackend;
}

type MvtLayerTypeDefinition = "fill" | "line";

interface MvtPaintDefinition {
  "fill-color"?: string;
  "line-color"?: string;
  "line-width"?: number;
}

interface MvtLayerDefinition {
  type: MvtLayerTypeDefinition;
  "source-layer": string;
  paint: MvtPaintDefinition;
  filter?: MvtFilter;
}

interface MvtStyleDefinition {
  layers: MvtLayerDefinition[];
}

// metadata.json is not part of the specification but typically generated by
// tippecanoe. https://github.com/mapbox/tippecanoe

const MVT_SUFFIX = "/{z}/{x}/{y}.mvt";
const getMvtMetadataUrl = (url: string): string => {
  return url.replace(MVT_SUFFIX, "/metadata.json");
};

// const RECT_BUFFER = 0.01; // One degree roughly translates to 100km
function buildMvtRectangle(metadata: any): TerriaRectangle | null {
  if (typeof metadata?.bounds !== "string") return null;
  const [west, south, east, north] = metadata.bounds
    .split(",")
    .map((str: string) => Number(str));
  const westEastBuffer = (east - west) * 0.2;
  const southNorthBuffer = (north - south) * 0.2;
  return {
    west: west - westEastBuffer,
    south: south - southNorthBuffer,
    east: east + westEastBuffer,
    north: north + southNorthBuffer,
  };
}

const parseMetadataJson = makeParseJson(
  object({
    bounds: string,
    json: string,
  }),
  null,
  `metadata.json の読み取りに失敗しました。`
);

const parseMetadataJsonInlineJson = makeParseJson(
  object({
    tilestats: object({
      layers: array(object({ layer: string, geometry: string })),
    }),
  }),
  null,
  `metadata.json の内容が不正です。`
);

const analyzeMetadata = (logger: Logger, metadataText: string) => {
  const metadata = parseMetadataJson(logger)(metadataText);
  if (!metadata)
    return {
      rectangle: null,
      layers: null,
    };
  const rectangle = buildMvtRectangle(metadata);
  const json = parseMetadataJsonInlineJson(logger)(metadata.json);
  if (!json) {
    return {
      rectangle: rectangle,
      layers: null,
    };
  }
  const layers = json.tilestats.layers;
  return { rectangle, layers };
};

const mvtPlugin =
  ({ backend }: MvtPluginOptions): Plugin =>
  (next) =>
  (node, parentId, logger) => {
    if (node.token.type !== "mvt") return next(node, parentId, logger);
    const legendName = node.token.props.get("legend");
    node.token.props.delete("legend");
    const deferredItem = next(node, parentId, logger);
    const deferredLegend = legendName
      ? backend.getLegend(logger, legendName)
      : new Deferred<null>((resolve) => resolve(null));
    const metadataUrl = getMvtMetadataUrl(node.token.url ?? "");
    const deferredMetadata = backend.fetch(logger, metadataUrl);
    return Deferred.all([deferredItem, deferredLegend, deferredMetadata]).then(
      ([item, maybeLegendEntries, metadataText]) => {
        const { rectangle, layers } = analyzeMetadata(logger, metadataText);
        const layersByName = layers?.reduce<
          Map<string, { layer: string; geometry: string }>
        >((acc, cur) => {
          acc.set(cur.layer, cur);
          return acc;
        }, new Map());
        const legendEntries: MvtLegendEntry[] = maybeLegendEntries
          ? maybeLegendEntries
          : layers
          ? layers.map((layer, i, { length }) => ({
              title: layer.layer,
              mvtLayer: layer.layer,
              color: `hsl(${(i / length) * 360} 100% 50%)`,
            }))
          : [];
        const filteredLegendRows = legendEntries.filter((entry) => {
          const mvtLayer = entry.mvtLayer;
          if (!mvtLayer) return false;
          if (entry.mvtAlwaysShow) return true;
          const shouldIgnoreCurrentLayer =
            layersByName && !layersByName.has(mvtLayer);
          return !shouldIgnoreCurrentLayer;
        });
        const fillLayers: MvtLayerDefinition[] = [];
        const lineLayers: MvtLayerDefinition[] = [];
        filteredLegendRows
          .slice()
          .sort((a, b) => {
            const keyA = Number(a.mvtLayerOrder);
            const keyB = Number(b.mvtLayerOrder);
            if (Number.isNaN(keyA) || Number.isNaN(keyB)) {
              return 0;
            }
            return keyA - keyB;
          })
          .forEach((row) => {
            // Rows without the "mvtLayer" property are already filtered out.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const mvtLayer = row.mvtLayer!;
            const layerMetadata = layersByName?.get(mvtLayer);
            const mvtFillColor = row.mvtFillColor;
            const mvtLineColor = row.mvtLineColor;
            const mvtLineWidth = Number(row.mvtLineWidth || "1");
            const mvtFilter = row.mvtFilter;
            const legendColor = row.color;
            const legendOutlineColor = row.outlineColor;
            const compiledFilter = mvtFilter
              ? compileFilterExpression(logger, mvtFilter)
              : null;
            const base: Partial<MvtLayerDefinition> &
              Pick<MvtLayerDefinition, "source-layer"> = {
              "source-layer": mvtLayer,
            };
            if (compiledFilter) base.filter = compiledFilter;
            const fillColor = mvtFillColor ?? legendColor;
            const lineColor = mvtLineColor ?? legendOutlineColor ?? legendColor;
            if (
              mvtFillColor || // The user explicitly requires this layer to be filled, or...
              (layerMetadata?.geometry === "Polygon" && fillColor) // this is a polygon layer and we have a color with which to fill the polygons.
            ) {
              // Define fill style.
              fillLayers.push({
                ...base,
                type: "fill",
                paint: {
                  "fill-color": fillColor,
                },
              });
            }
            if (
              mvtLineColor ||
              legendOutlineColor || // The user explicitly requires this layer to be stroked, or...
              (layerMetadata?.geometry === "LineString" && lineColor) // this is a line layer and we have a color with which to stroke the lines.
            ) {
              // Define stroke style.
              lineLayers.push({
                ...base,
                type: "line",
                paint: {
                  "line-color": lineColor,
                  "line-width": mvtLineWidth,
                },
              });
            }
          });

        const style: MvtStyleDefinition = {
          layers: [...fillLayers, ...lineLayers],
        };
        item.style = style;
        item.legends = [buildLegend(filteredLegendRows)];

        if (rectangle) item.rectangle = rectangle;
        return item;
      }
    );
  };

export default mvtPlugin;
